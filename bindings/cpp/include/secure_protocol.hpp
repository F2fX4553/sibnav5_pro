#ifndef SECURE_PROTOCOL_HPP
#define SECURE_PROTOCOL_HPP

#include <cstdint>
#include <vector>
#include <string>
#include <memory>
#include <functional>
#include <optional>

// Include the C header generated by cbindgen
// In a real build, we'd ensure this file exists
extern "C" {
    #include "../../../bindings/c/secure_protocol.h"
}

namespace secure {

// Error Codes
enum class ErrorCode : int32_t {
    Success = 0,
    InvalidKeyLength = 1,
    EncryptionFailed = 2,
    DecryptionFailed = 3,
    SessionNotFound = 4,
    UnknownError = 255
};

class SecureContext;
class SecureSession;

struct Config {
    bool enable_forward_secrecy = true;
    bool enable_post_compromise_security = true;
    size_t max_skipped_messages = 2000;
    uint64_t key_rotation_interval = 86400; // 24 hours
    uint64_t handshake_timeout = 30; // seconds
    size_t message_buffer_size = 1024;
};

class SecureContext {
public:
    static std::unique_ptr<SecureContext> Create(const Config& config = {});
    ~SecureContext();

    std::unique_ptr<SecureSession> CreateSession(const std::vector<uint8_t>& peer_id);

private:
    SecureContext(SecureContextHandle* handle);
    SecureContextHandle* handle_;
};

class SecureSession {
public:
    SecureSession(SecureSessionHandle* handle);
    ~SecureSession();

    std::vector<uint8_t> Encrypt(const std::vector<uint8_t>& plaintext);
    std::vector<uint8_t> Decrypt(const std::vector<uint8_t>& ciphertext);

private:
    SecureSessionHandle* handle_;
};

// Key generation utility
struct KeyPair {
    std::vector<uint8_t> public_key;
    std::vector<uint8_t> private_key;
};

KeyPair GenerateKeyPair();

} // namespace secure

#endif // SECURE_PROTOCOL_HPP
